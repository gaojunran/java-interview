---
title: 059 Redis 实现分布式锁时可能遇到的问题有哪些？
---

Redis 实现分布式锁是一种常见的做法，但要正确、健壮地实现一个可靠的分布式锁机制其实并不简单。在实践中容易踩坑。下面我们详细讲讲 Redis 分布式锁可能遇到的问题及其原因：

---

## 一、锁失效问题

### 问题描述：

客户端 A 获得锁后执行耗时任务，期间锁因超时时间到期自动释放，客户端 B 获得锁，而客户端 A 执行完毕后误释放了 B 的锁。

### 示例场景：

* 客户端 A 设置了 10 秒过期时间；
* A 执行任务用了 15 秒；
* B 在第 10 秒后获得锁；
* A 在第 15 秒执行完，**还以为自己持有锁，执行 `DEL` 操作释放锁**，实际上却释放了 B 的锁。

### 解决方案：

* 加锁时使用 **唯一标识（如 UUID）** 作为锁值；
* 释放锁时要先判断锁的值是否为自己设置的（使用 Lua 脚本原子检查+删除）；

```lua
-- 释放锁的 Lua 脚本（原子操作）
if redis.call("get", KEYS[1]) == ARGV[1] then
  return redis.call("del", KEYS[1])
else
  return 0
end
```

---

## 二、锁续期失败

### 问题描述：

某些任务耗时不可控，锁过期前需要自动续期，如果续期失败就会造成锁提前释放，其他客户端错误获得锁。

### 解决方案：

* 使用 **“看门狗机制”**：定期（如每 3 秒）自动给锁续期，直到任务结束；
* 可以使用如 Redisson（Java Redis 客户端）内置的锁续期机制。

---

## 三、非原子加锁操作

### 问题描述：

如果使用非原子的 `SETNX` + `EXPIRE` 实现锁，会在 `SETNX` 成功但 `EXPIRE` 失败时造成**死锁**（永久持有）。

### 错误做法：

```bash
SETNX lock_key myid
EXPIRE lock_key 10  # 如果宕机在这步之前，锁永不过期
```

### 正确做法：

* 使用 Redis `SET` 命令的原子语法：

```bash
SET lock_key myid NX EX 10
```

表示：**只在不存在时设置，并且设置过期时间，原子完成**。

---

## 四、时钟漂移问题（多节点环境）

### 问题描述：

当使用多个 Redis 节点实现锁（比如使用 Redlock 算法），不同节点之间的系统时钟不同步，会导致加锁和判断超时不一致，进而产生安全问题。

### 解决方案：

* 如果使用 Redlock，要确保节点时钟尽可能同步；
* **Redlock 本身存在争议**，一些专家（如 Martin Kleppmann）认为其不安全；
* 更推荐在**单个 Redis 节点（高可用配置）中使用分布式锁**，而不是跨多个 Redis 节点；

---

## 五、网络分区问题（脑裂）

### 问题描述：

在 Redis Sentinel 或 Redis Cluster 模式下，如果发生主从切换或网络分区，可能导致锁状态不一致。

例如：

* 客户端 A 连到原主节点加了锁；
* 原主与其他节点断连，被降级为从节点；
* 另一个节点被提升为主，客户端 B 连上新主也加了锁；
* 实际出现“**两客户端都加锁成功**”的脑裂情况。

### 解决方案：

* 使用具有强一致性的 Redis 服务（如单机部署 + 哨兵高可用）；
* 避免在切主频繁的系统中依赖 Redis 实现强一致性锁；
* 或使用 ZooKeeper / etcd 实现强一致分布式锁。

---

## 六、锁未释放（程序异常退出）

### 问题描述：

加锁后程序异常崩溃或宕机，导致锁永远不被释放。

### 解决方案：

* 设置锁的 **过期时间**（如 `SET NX EX`）；
* 对于业务耗时不定的场景，使用**锁续期机制（watchdog）**；
* 或在程序重启后判断锁状态是否需要补偿处理。

---

## 七、锁粒度设计不当

### 问题描述：

* 锁粒度太大：多个无关任务竞争同一把锁，降低并发性能；
* 锁粒度太小：难以维护，容易出错。

### 解决方案：

* 合理划分锁粒度（例如：按资源 ID、业务 ID）；
* 支持可重入锁 / 读写锁（如 Redisson 提供的高级锁实现）；

---

## 八、并发重试机制不当

### 问题描述：

大量客户端竞争锁失败后频繁重试，造成 Redis 压力过大。

### 解决方案：

* 加入\*\*指数退避 + 随机抖动（jitter）\*\*的重试策略；
* 限制重试次数；
* 尽量减少无效抢锁操作；

---

## 总结

| 问题类型      | 原因 / 风险             | 推荐措施                  |
| --------- | ------------------- | --------------------- |
| 锁误释放      | UUID 不唯一 / 释放锁前未校验  | Lua 脚本原子释放            |
| 锁自动失效     | 任务耗时大于锁有效期          | Watchdog 自动续期         |
| 加锁非原子     | SETNX + EXPIRE 分离操作 | SET key NX EX 10 原子命令 |
| 脑裂 / 网络分区 | Redis 主从切换期间锁状态不一致  | 使用高可用或改用 Zookeeper    |
| 崩溃未释放     | 程序异常退出              | 设置锁过期时间               |
| 锁粒度设计不当   | 全局锁或锁太细，影响性能或维护困难   | 合理划分锁粒度               |
| 并发重试频繁    | 无重试策略导致 Redis 压力    | 指数退避+抖动               |

---

继续提问：https://chatgpt.com/share/68766f26-4718-8010-9eb8-8f8445aeeb3b
