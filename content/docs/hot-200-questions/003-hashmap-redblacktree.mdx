---
title: 003 为什么 JDK 1.8 对 HashMap 进行了红黑树的改动？
---

JDK 1.8 对 `HashMap` 的底层实现做了重要改动，其中最关键的是：**当某个桶中的链表长度超过一定阈值（默认为 8）且数组长度大于等于 64 时，会将链表转换为红黑树**。这个改动的目的主要有以下几点：

---

### ✅ 一、提高性能（优化极端情况下的查询效率）

#### 背景问题：

在 JDK 1.7 及之前版本，`HashMap` 中每个桶的冲突是通过**链表**来处理的。当哈希冲突严重时（即很多 key 被映射到同一个桶），链表会变得很长，查找一个 key 需要 **O(n)** 的时间复杂度。

#### 改动动机：

* 红黑树是一种自平衡二叉搜索树，查找的时间复杂度为 **O(log n)**。
* 通过将长链表转为红黑树，**在极端情况下也能保持高性能查找效率**。

---

### ✅ 二、提升整体哈希性能稳定性（降低最坏时间复杂度）

#### 示例：

假设你有大量冲突的 key，比如恶意用户或糟糕的哈希函数，导致大量元素冲到一个桶中：

| JDK 1.7 | 查询一个 key 最坏情况是 O(n)，可能被链表拖慢 |
| ------- | --------------------------- |
| JDK 1.8 | 查询一个 key 最坏是 O(log n)，稳定性更好 |

这对于一些高并发、高性能场景（比如缓存系统、实时计算框架）非常关键。

---

### ✅ 三、并非所有链表都转树：有条件触发

| 条件         | 说明                         |
| ---------- | -------------------------- |
| 链表长度 ≥ 8   | 如果某个桶的链表元素达到 8 个及以上        |
| 哈希表长度 ≥ 64 | 表示容量足够大，不轻易转换（避免在小表中过度复杂化） |

否则就算链表再长，也暂时保留为链表结构。

---

### ✅ 四、插入与删除带来的复杂性被权衡

红黑树的增删比链表更复杂，但：

* 查找频率远大于插入/删除。
* `HashMap` 主要用于高频读操作场景。
* 因此在性能上是“读多写少”的最优平衡。

---

### ✅ 总结一句话：

> **JDK 1.8 为了优化 HashMap 在高哈希冲突情况下的性能，将链表结构改进为红黑树，降低最坏时间复杂度，从 O(n) 优化为 O(log n)，提高查找的效率与稳定性。**

---

继续提问：https://chatgpt.com/share/686b3452-cf14-8010-9a02-3220d4b47a75

