---
title: 066 	Redis 中如何保证缓存与数据库的数据一致性？
---

在实际开发中，**缓存一致性**是指 **Redis 中的数据与数据库中的数据保持同步一致**。否则会出现“缓存中的旧数据”覆盖“数据库的最新数据”或读取到过期数据的问题。

### 一、常见的缓存一致性问题场景

1. **读操作缓存穿透**：

   * 缓存未命中 → 读数据库 → 数据写入缓存。
   * 如果两个线程并发操作，可能导致写入旧数据。

2. **写操作引起的不一致**：

   * 写数据库成功，但写缓存失败或顺序不当。
   * 可能缓存中依旧是旧数据。

---

### 二、缓存一致性的几种策略

#### 1. **先更新数据库，再删除缓存（推荐）**

##### 流程：

```
更新请求 → 更新数据库 → 删除缓存
```

##### 示例代码：

```java
// 更新用户
public void updateUser(User user) {
    userMapper.update(user);              // 1. 更新数据库
    redisTemplate.delete("user:" + user.getId()); // 2. 删除缓存
}
```

##### 优点：

* 简单、通用，防止写入旧数据。
* 删除缓存比更新缓存更安全。

##### 问题（并发下的时序问题）：

* 读请求发生在“写数据库”与“删缓存”之间，会读到旧数据并回填缓存（脏数据）。

##### 解决方法：

* **加分布式锁**（如 Redisson）。
* 或使用 **延迟双删策略**。

#### 2. **延迟双删策略**

##### 流程：

```
更新数据库 → 删除缓存 → 延迟一段时间后再次删除缓存
```

##### 示例代码：

```java
userMapper.update(user);
redisTemplate.delete("user:" + user.getId());
Thread.sleep(500); // 延迟
redisTemplate.delete("user:" + user.getId());
```

##### 原因：

防止第一个删缓存后，立即有并发请求读到了旧缓存。

---

#### 3. **先删除缓存，再更新数据库（不推荐）**

##### 流程：

```
删除缓存 → 更新数据库
```

##### 风险：

* 如果更新数据库失败，缓存已经被删除，下一次查询会缓存空数据或旧数据。

---

#### 4. **先更新数据库，再更新缓存**

##### 流程：

```
更新数据库 → 更新缓存
```

##### 问题：

* 如果缓存更新失败，就会导致脏数据。
* 数据并发更新时，顺序无法保证。

---

#### 5. **使用消息队列保证最终一致性（异步方案）**

##### 思路：

* 更新数据库成功后，将变更信息写入 MQ（如 Kafka、RocketMQ）。
* 异步消费者监听变更消息，再更新或删除 Redis 缓存。

##### 优点：

* 解耦、可异步处理大流量。
* 最终一致性，但非强一致。

##### 问题：

* 增加了系统复杂度。
* 需要处理消息丢失、重复消费等问题。

---

### 三、实际项目中的推荐方案

#### ✅ 一般业务（强一致性要求不高）：

* **更新数据库 → 删除缓存**。
* 加上**延迟双删**可提高一致性。

#### ✅ 高并发/强一致性场景：

* **加分布式锁**防止读写冲突。
* 或者使用 **Canal + 消息队列**监听数据库 binlog 变更，再同步缓存。

---

### 四、总结对比

| 策略           | 一致性 | 实现难度 | 适用场景       |
| ------------ | --- | ---- | ---------- |
| 更新数据库 → 删除缓存 | 中   | 简单   | 通用推荐方案     |
| 延迟双删         | 高   | 中    | 一致性要求较高的业务 |
| 删除缓存 → 更新数据库 | 低   | 简单   | 不推荐        |
| 更新数据库 → 更新缓存 | 低   | 简单   | 数据不经常更新的业务 |
| MQ 异步同步缓存    | 高   | 高    | 高并发、复杂业务场景 |

如需具体场景代码或方案优化建议，也可以继续问我。
