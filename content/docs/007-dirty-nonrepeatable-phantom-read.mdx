---
title: 007 数据库的脏读、不可重复读和幻读分别是什么？
---

数据库中的**脏读（Dirty Read）**、**不可重复读（Non-repeatable Read）**和**幻读（Phantom Read）**是并发事务执行时常见的三种**读现象问题**。理解它们有助于掌握事务隔离级别对数据一致性的影响。

---

## 🔹 1. 脏读（Dirty Read）

### ❓定义：

一个事务读到了**另一个未提交事务修改的数据**。

### 📌 举例：

* 事务 A：更新用户账户余额 `update account set balance = 500 where id = 1;`（未提交）
* 事务 B：读取账户余额 `select balance from account where id = 1;` → 得到 `500`
* 此时事务 A 回滚，余额恢复为原值 `1000`
* 事务 B 读到的是一个“脏”数据（实际上从未存在过）

### 🚨 问题：

数据不一致，事务 B 使用了一个**可能被撤销的中间状态**

---

## 🔹 2. 不可重复读（Non-repeatable Read）

### ❓定义：

**在同一个事务中，两次读取同一条记录的结果不一样**，因为中间被其他事务修改并提交了。

### 📌 举例：

* 事务 A：读取商品价格 `select price from product where id = 1;` → `100`
* 事务 B：修改该商品价格为 `120` 并提交
* 事务 A 再次读取价格 `select price from product where id = 1;` → `120`

### 🚨 问题：

同一事务中查询结果不一致，**读的数据“被别人改了”**

---

## 🔹 3. 幻读（Phantom Read）

### ❓定义：

**在同一个事务中，两次查询某个范围的记录，第二次多出（或少了）一些记录**，因为其他事务新增或删除了满足查询条件的记录。

### 📌 举例：

* 事务 A：查询工资 > 5000 的员工数量 → 得到 `10` 个
* 事务 B：插入一条工资为 `6000` 的新员工并提交
* 事务 A 再次查询工资 > 5000 的员工数量 → 得到 `11` 个

### 🚨 问题：

范围查询结果不一致，感觉“幻影般”地出现了新记录

---

## 🔒 与事务隔离级别的关系

| 隔离级别                 | 脏读 | 不可重复读 | 幻读                 |
| -------------------- | -- | ----- | ------------------ |
| **Read Uncommitted** | ✅  | ✅     | ✅                  |
| **Read Committed**   | ❌  | ✅     | ✅                  |
| **Repeatable Read**  | ❌  | ❌     | ✅（MySQL InnoDB 已防） |
| **Serializable**     | ❌  | ❌     | ❌                  |

* ✅：可能发生
* ❌：被防止

> 📝 MySQL 的 InnoDB 引擎在 `Repeatable Read` 下利用 **间隙锁（Gap Lock）** 也防止了幻读，虽然标准定义上并不一定如此。

---

## 总结口诀（重点）：

* **脏读**：读到了**别人没提交的修改**
* **不可重复读**：读到了**别人提交的修改**
* **幻读**：读到了**别人新插入或删除的行**

---

继续提问：https://chatgpt.com/share/686ce167-10b8-8010-a2b2-67de40df0c07

