---
title: 035 MySQL 中的事务隔离级别有哪些？
---


MySQL 中的事务隔离级别有 **四种**，它们决定了一个事务能看到其他事务未提交的数据的程度。每种隔离级别都会影响数据库的并发性、性能和一致性。

---

### 🔒 四种事务隔离级别（从低到高）

| 隔离级别                  | 脏读   | 不可重复读 | 幻读               |
| --------------------- | ---- | ----- | ---------------- |
| **读未提交（RU）**          | ✅ 可能 | ✅ 可能  | ✅ 可能             |
| **读已提交（RC）**          | ❌ 避免 | ✅ 可能  | ✅ 可能             |
| **可重复读（RR）**          | ❌ 避免 | ❌ 避免  | ✅ 可能（InnoDB 可避免） |
| **串行化（Serializable）** | ❌ 避免 | ❌ 避免  | ❌ 避免             |

---

## 1️⃣ 读未提交（Read Uncommitted）

* **特性**：可以读到其他事务还未提交的数据（**脏读**）。
* **问题**：数据不一致风险最高，读取的数据可能稍后被回滚。
* **使用场景**：极少数要求高并发、对准确性要求不高的系统。

✅ 能最大化并发性
❌ 准确性最差

---

## 2️⃣ 读已提交（Read Committed）【多数数据库默认】

* **特性**：只能读取到其他事务**已经提交**的数据。
* **问题**：会出现 **不可重复读**，即同一个查询在同一事务中多次执行，结果不同。
* **应用场景**：多数商业数据库（如 Oracle）采用它作为默认级别。

✅ 避免脏读
❌ 无法保证一致视图

---

## 3️⃣ 可重复读（Repeatable Read）【MySQL InnoDB 默认】

* **特性**：在一个事务中对同一条记录的多次读取结果一致，使用 **快照读（MVCC）** 保证一致性。
* **问题**：可能出现**幻读**（如第一次看到 3 行，后面插入了符合条件的新行）。
* **InnoDB 机制**：通过 **间隙锁（Gap Lock）** 来避免幻读。

✅ 避免脏读、不可重复读
⚠️ 幻读（逻辑上存在，但 InnoDB 会避免）

---

## 4️⃣ 串行化（Serializable）

* **特性**：事务顺序执行，**强制加锁（包括范围锁）**，实现严格的隔离。
* **问题**：并发极低，性能下降严重。
* **使用场景**：要求极高一致性，如金融转账等。

✅ 避免所有并发问题
❌ 性能最差

---

### 🔄 隔离级别切换语法

```sql
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;
-- 执行查询和更新操作
COMMIT;
```

---

### 🔍 三种并发异常回顾

| 异常类型      | 含义                           |
| --------- | ---------------------------- |
| **脏读**    | 读到其他事务未提交的数据                 |
| **不可重复读** | 一次事务内多次读取，结果不一致（因为别人修改并提交了）  |
| **幻读**    | 同一个查询返回的行数不一致（别人插入了新的符合条件的行） |

---

### 🧠 总结推荐

| 隔离级别         | 并发性  | 一致性  | 推荐情况          |
| ------------ | ---- | ---- | ------------- |
| RU           | ⭐⭐⭐⭐ | ⭐    | 基本不用          |
| RC           | ⭐⭐⭐  | ⭐⭐   | 中等一致性要求       |
| RR           | ⭐⭐   | ⭐⭐⭐  | MySQL 默认、推荐   |
| Serializable | ⭐    | ⭐⭐⭐⭐ | 严格一致性需求，如银行系统 |

---

## 补充：MySQL 的 InnoDB 如何处理幻读？

✅ 幻读（Phantom Read）是什么？

**幻读**是指：

> 在同一个事务中，**两次执行相同的查询**，第一次看到某些记录，**第二次看到多了“新的行”**，这些“新行”是在两次查询之间**被其他事务插入的**，并且满足查询条件。

### 📌 举个例子：

假设你在操作一个订单表：

```sql
-- T1 事务开始
START TRANSACTION;
-- 查询订单总数
SELECT COUNT(*) FROM orders WHERE user_id = 42;
-- 假设返回 3 条记录
```

此时另一个事务 T2 插入了一条新订单：

```sql
-- T2 事务
START TRANSACTION;
INSERT INTO orders(user_id, amount) VALUES (42, 100);
COMMIT;
```

然后你在 T1 中再次执行相同的查询：

```sql
-- T1 再次执行查询
SELECT COUNT(*) FROM orders WHERE user_id = 42;
-- 结果：4 条记录（新增了“幻影行”）
```

这就是 **幻读**：你第二次查询时看到了“你原本看不到”的新记录，它“幻影”般出现了。

---

## 🛡️ InnoDB 如何处理幻读（可重复读）

MySQL 的 InnoDB 引擎在 **RR（可重复读）** 隔离级别中是如何避免幻读的呢？

### ✨ 关键机制：**间隙锁（Gap Lock）** + **MVCC 快照读**

#### 🔸 MVCC（多版本并发控制）：

* 用于**快照读**，读取数据时不是直接读最新的行，而是读事务开始时可见的版本。
* 对于 `SELECT ... WHERE ...` 查询，InnoDB 不加锁，只是构造一个一致的“读视图”。

#### 🔸 间隙锁（Gap Lock）：

* 如果你用 `SELECT ... FOR UPDATE` 或更新语句，InnoDB 会**锁定满足条件的记录**，并且锁住前后的“间隙”。
* 这样，**其他事务无法在这个范围内插入新记录**，避免幻读。

#### 📌 示例：

```sql
-- T1
START TRANSACTION;
SELECT * FROM orders WHERE user_id = 42 FOR UPDATE;
-- InnoDB 加锁：锁住 user_id=42 的所有记录及其间隙
```

此时 T2 想插入 `user_id=42` 的记录，会被阻塞，直到 T1 提交。

---

继续提问：https://chatgpt.com/share/68736317-bad4-8010-b6cf-fe6046c2995b
