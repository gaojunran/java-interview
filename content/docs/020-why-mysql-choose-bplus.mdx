---
title: 020 为什么 MySQL 选择使用 B+ 树作为索引结构？
---

MySQL（特别是 InnoDB 引擎）选择 **B+ 树** 作为索引结构的原因，主要是因为它非常适合 **数据库这种读多写少**、**大规模数据存储**、**磁盘 I/O 成本高** 的使用场景。

下面详细讲讲原因：

---

## 一、B+ 树结构特点

B+ 树是在 B 树的基础上做了优化，具体特点如下：

1. **所有数据都存储在叶子节点**（非叶子节点只存储键）
   ➜ 使得非叶子节点更小、更紧凑，能存储更多的键，从而**降低树的高度**

2. **叶子节点通过链表指针连接**
   ➜ 天然支持范围查询和有序遍历（如 `BETWEEN`、`>、<、ORDER BY`）

3. **多路查找树（高阶）**
   ➜ 每个节点可以有很多孩子，从而**减少树的层数**

---

## 二、为什么适合数据库索引？

### 1. **减少磁盘 I/O 次数（提高查询效率）**

* 磁盘 I/O 是数据库中最耗时的操作。
* B+ 树通过更高的“分支因子”降低了树高（通常只有 2～4 层）。
* 查找某条记录时，只需访问少数几个磁盘块（页）：

  ```
  根节点 → 中间节点 → 叶子节点
  ```

### 2. **更适合范围查询与排序**

* 因为所有数据都在叶子节点且**叶子节点之间有指针连接**
* 所以范围查询（`age BETWEEN 10 AND 20`）或者排序遍历（`ORDER BY`）非常高效，只需遍历叶子节点链表即可，不需要中序遍历整棵树。

### 3. **数据块利用率更高**

* 非叶子节点只存键，不存值，占用空间小 → 每个节点能存放更多键
* 相比 B 树：一个磁盘页能容纳更多分支 → **扇出更大 → 树更“矮”**
* 更矮意味着 **更少的磁盘读取次数**

### 4. **写入操作也较高效**

* 插入新数据只影响叶子节点，必要时会拆分节点
* 修改索引（如插入/删除）过程中，不用频繁调整整棵树结构

---

## 三、B+ 树 VS 其他结构

对比 B 树：

| 对比点    | B 树      | B+ 树             |
| ------ | -------- | ---------------- |
| 数据存储   | 所有节点都有数据 | **只有叶子节点存数据**    |
| 范围查询效率 | 要遍历整棵树   | **只遍历叶子链表，很快**   |
| 空间利用率  | 每层节点都很大  | **非叶节点小，扇出高，树矮** |
| 排序遍历效率 | 不支持顺序访问  | **叶子节点天然链表连接**   |

对比其他结构：

| 结构      | 说明        | 适合场景          | 不适合的点             |
| ------- | --------- | ------------- | ----------------- |
| **哈希表** | 通过哈希定位    | 精确查找（=）       | 不支持范围查询、有序性差      |
| **跳表**  | 多层链表跳跃查找  | Redis 使用，适合内存 | 对磁盘不友好、随机访问性能差    |

---

## 四、总结

MySQL 使用 B+ 树索引，是因为它具备：

✅ 高度平衡、查找效率高

✅ 数据在叶子节点，顺序结构（叶子节点间链表相连）支持范围查询

✅ 磁盘读写友好，I/O 次数少

✅ 插入、删除代价适中，适合动态数据集

这使得它在大多数数据库场景中（尤其是需要频繁读取+范围查找的 OLTP 系统）成为最优选择。

---

继续提问：https://chatgpt.com/share/686dcef1-899c-8010-8474-1fb0551abbdf
